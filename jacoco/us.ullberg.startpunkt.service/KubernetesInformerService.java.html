<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KubernetesInformerService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">startpunkt</a> &gt; <a href="index.source.html" class="el_package">us.ullberg.startpunkt.service</a> &gt; <span class="el_source">KubernetesInformerService.java</span></div><h1>KubernetesInformerService.java</h1><pre class="source lang-java linenums">package us.ullberg.startpunkt.service;

import io.fabric8.kubernetes.api.model.GenericKubernetesResource;
import io.fabric8.kubernetes.client.KubernetesClient;
import io.fabric8.kubernetes.client.dsl.base.ResourceDefinitionContext;
import io.fabric8.kubernetes.client.informers.ResourceEventHandler;
import io.fabric8.kubernetes.client.informers.SharedIndexInformer;
import io.quarkus.logging.Log;
import io.quarkus.runtime.ShutdownEvent;
import io.quarkus.runtime.StartupEvent;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CopyOnWriteArrayList;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import us.ullberg.startpunkt.crd.v1alpha4.Application;
import us.ullberg.startpunkt.crd.v1alpha4.Bookmark;
import us.ullberg.startpunkt.messaging.EventBroadcaster;
import us.ullberg.startpunkt.objects.ApplicationResponse;
import us.ullberg.startpunkt.objects.BookmarkResponse;
import us.ullberg.startpunkt.objects.kubernetes.BaseKubernetesObject;
import us.ullberg.startpunkt.objects.kubernetes.GatewayApiHttpRouteWrapper;
import us.ullberg.startpunkt.objects.kubernetes.HajimariApplicationWrapper;
import us.ullberg.startpunkt.objects.kubernetes.IngressApplicationWrapper;
import us.ullberg.startpunkt.objects.kubernetes.IstioVirtualServiceApplicationWrapper;
import us.ullberg.startpunkt.objects.kubernetes.RouteApplicationWrapper;
import us.ullberg.startpunkt.objects.kubernetes.StartpunktApplicationWrapper;

/**
 * Service that uses Kubernetes Informers to watch resources and maintain the application and
 * bookmark caches.
 *
 * &lt;p&gt;Informers provide automatic reconnection, resync, and resource version management, eliminating
 * the need for manual watch restart logic.
 *
 * &lt;p&gt;Informers are established for: - Application CRDs (startpunkt.ullberg.us) - Bookmark CRDs
 * (startpunkt.ullberg.us and hajimari.io) - Ingress resources (if enabled) - Route resources
 * (OpenShift, if enabled) - VirtualService resources (Istio, if enabled) - HTTPRoute resources
 * (Gateway API, if enabled)
 */
@ApplicationScoped
public class KubernetesInformerService {

  private final KubernetesClient kubernetesClient;
  private final ApplicationCacheService applicationCacheService;
  private final BookmarkCacheService bookmarkCacheService;
  private final EventBroadcaster eventBroadcaster;
  private final AvailabilityCheckService availabilityCheckService;
  private final BookmarkService bookmarkService;

  // List to hold all active informers for cleanup on shutdown
<span class="fc" id="L55">  private final List&lt;SharedIndexInformer&lt;?&gt;&gt; informers = new CopyOnWriteArrayList&lt;&gt;();</span>

  // Flag to suppress cache reload during initial sync
<span class="fc" id="L58">  private volatile boolean initialSyncComplete = false;</span>

  // Flags to track which resource types are available in the cluster
<span class="fc" id="L61">  private volatile boolean hajimariResourcesAvailable = false;</span>
<span class="fc" id="L62">  private volatile boolean ingressResourcesAvailable = false;</span>
<span class="fc" id="L63">  private volatile boolean openshiftResourcesAvailable = false;</span>
<span class="fc" id="L64">  private volatile boolean istioResourcesAvailable = false;</span>
<span class="fc" id="L65">  private volatile boolean gatewayApiResourcesAvailable = false;</span>

  @ConfigProperty(name = &quot;startpunkt.hajimari.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean hajimariEnabled;

  @ConfigProperty(name = &quot;startpunkt.ingress.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean ingressEnabled;

  @ConfigProperty(name = &quot;startpunkt.ingress.onlyAnnotated&quot;, defaultValue = &quot;true&quot;)
  boolean ingressOnlyAnnotated;

  @ConfigProperty(name = &quot;startpunkt.openshift.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean openshiftEnabled;

  @ConfigProperty(name = &quot;startpunkt.openshift.onlyAnnotated&quot;, defaultValue = &quot;true&quot;)
  boolean openshiftOnlyAnnotated;

  @ConfigProperty(name = &quot;startpunkt.istio.virtualservice.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean istioVirtualServiceEnabled;

  @ConfigProperty(name = &quot;startpunkt.istio.virtualservice.onlyAnnotated&quot;, defaultValue = &quot;true&quot;)
  boolean istioVirtualServiceOnlyAnnotated;

  @ConfigProperty(name = &quot;startpunkt.gatewayapi.httproute.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean gatewayApiEnabled;

  @ConfigProperty(name = &quot;startpunkt.gatewayapi.httproute.onlyAnnotated&quot;, defaultValue = &quot;true&quot;)
  boolean gatewayApiHttpRouteOnlyAnnotated;

  @ConfigProperty(name = &quot;startpunkt.namespaceSelector.any&quot;, defaultValue = &quot;true&quot;)
  boolean anyNamespace;

  @ConfigProperty(name = &quot;startpunkt.namespaceSelector.matchNames&quot;)
  Optional&lt;List&lt;String&gt;&gt; matchNames;

  @ConfigProperty(name = &quot;startpunkt.defaultProtocol&quot;, defaultValue = &quot;http&quot;)
  String defaultProtocol;

  @ConfigProperty(name = &quot;startpunkt.watch.enabled&quot;, defaultValue = &quot;true&quot;)
  boolean watchEnabled;

  @ConfigProperty(name = &quot;startpunkt.watch.resyncPeriodSeconds&quot;, defaultValue = &quot;300&quot;)
  long resyncPeriodSeconds;

  /** Constructor with injected dependencies. */
  public KubernetesInformerService(
      KubernetesClient kubernetesClient,
      ApplicationCacheService applicationCacheService,
      BookmarkCacheService bookmarkCacheService,
      EventBroadcaster eventBroadcaster,
      AvailabilityCheckService availabilityCheckService,
<span class="fc" id="L116">      BookmarkService bookmarkService) {</span>
<span class="fc" id="L117">    this.kubernetesClient = kubernetesClient;</span>
<span class="fc" id="L118">    this.applicationCacheService = applicationCacheService;</span>
<span class="fc" id="L119">    this.bookmarkCacheService = bookmarkCacheService;</span>
<span class="fc" id="L120">    this.eventBroadcaster = eventBroadcaster;</span>
<span class="fc" id="L121">    this.availabilityCheckService = availabilityCheckService;</span>
<span class="fc" id="L122">    this.bookmarkService = bookmarkService;</span>
<span class="fc" id="L123">  }</span>

  /**
   * Checks if a resource type exists in the cluster by verifying the CRD or API resource.
   *
   * @param group the API group (e.g., &quot;networking.k8s.io&quot;)
   * @param version the API version (e.g., &quot;v1&quot;)
   * @param plural the plural resource name (e.g., &quot;ingresses&quot;)
   * @param resourceTypeName the friendly name for logging (e.g., &quot;Ingress&quot;)
   * @return true if the resource type exists, false otherwise
   */
  private boolean resourceTypeExists(
      String group, String version, String plural, String resourceTypeName) {
    try {
<span class="fc" id="L137">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L139">              .withGroup(group)</span>
<span class="fc" id="L140">              .withVersion(version)</span>
<span class="fc" id="L141">              .withPlural(plural)</span>
<span class="fc" id="L142">              .withNamespaced(true)</span>
<span class="fc" id="L143">              .build();</span>

      // Try to list resources to verify the type exists
<span class="fc" id="L146">      kubernetesClient.genericKubernetesResources(ctx).inAnyNamespace().list();</span>
<span class="fc" id="L147">      return true;</span>
<span class="fc" id="L148">    } catch (Exception e) {</span>
<span class="fc" id="L149">      Log.infof(</span>
          &quot;%s resources (%s/%s/%s) not available in cluster - skipping informer&quot;,
          resourceTypeName, group, version, plural);
<span class="fc" id="L152">      Log.debugf(e, &quot;Details for %s resource check&quot;, resourceTypeName);</span>
<span class="fc" id="L153">      return false;</span>
    }
  }

  /**
   * Initializes informers and starts watching Kubernetes resources on application startup.
   * Informers are started asynchronously to avoid blocking application startup.
   */
  void onStart(@Observes StartupEvent event) {
<span class="fc" id="L162">    Log.info(&quot;Initializing Kubernetes Informer service&quot;);</span>

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">    if (!watchEnabled) {</span>
<span class="nc" id="L165">      Log.info(&quot;Kubernetes informers disabled by configuration&quot;);</span>
<span class="nc" id="L166">      return;</span>
    }

    // Start informers asynchronously to avoid blocking startup
    // This is especially important for native mode where K8s API may not be available
<span class="fc" id="L171">    new Thread(</span>
            () -&gt; {
              try {
                // Start informers for different resource types
<span class="fc" id="L175">                startApplicationInformer();</span>
<span class="fc" id="L176">                startBookmarkInformer();</span>

<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                if (hajimariEnabled</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                    &amp;&amp; resourceTypeExists(</span>
                        &quot;hajimari.io&quot;, &quot;v1alpha1&quot;, &quot;bookmarks&quot;, &quot;Hajimari Bookmark&quot;)) {
<span class="fc" id="L181">                  hajimariResourcesAvailable = true;</span>
<span class="fc" id="L182">                  startHajimariBookmarkInformer();</span>
                }

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                if (ingressEnabled</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                    &amp;&amp; resourceTypeExists(&quot;networking.k8s.io&quot;, &quot;v1&quot;, &quot;ingresses&quot;, &quot;Ingress&quot;)) {</span>
<span class="fc" id="L187">                  ingressResourcesAvailable = true;</span>
<span class="fc" id="L188">                  startIngressInformer();</span>
                }

<span class="pc bpc" id="L191" title="1 of 2 branches missed.">                if (openshiftEnabled</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                    &amp;&amp; resourceTypeExists(</span>
                        &quot;route.openshift.io&quot;, &quot;v1&quot;, &quot;routes&quot;, &quot;OpenShift Route&quot;)) {
<span class="fc" id="L194">                  openshiftResourcesAvailable = true;</span>
<span class="fc" id="L195">                  startRouteInformer();</span>
                }

<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                if (istioVirtualServiceEnabled</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">                    &amp;&amp; resourceTypeExists(</span>
                        &quot;networking.istio.io&quot;, &quot;v1&quot;, &quot;virtualservices&quot;, &quot;Istio VirtualService&quot;)) {
<span class="fc" id="L201">                  istioResourcesAvailable = true;</span>
<span class="fc" id="L202">                  startVirtualServiceInformer();</span>
                }

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">                if (gatewayApiEnabled</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">                    &amp;&amp; resourceTypeExists(</span>
                        &quot;gateway.networking.k8s.io&quot;, &quot;v1&quot;, &quot;httproutes&quot;, &quot;Gateway API HTTPRoute&quot;)) {
<span class="fc" id="L208">                  gatewayApiResourcesAvailable = true;</span>
<span class="fc" id="L209">                  startHttpRouteInformer();</span>
                }

<span class="fc" id="L212">                Log.infof(</span>
<span class="fc" id="L213">                    &quot;Kubernetes Informer service initialized with %d informers&quot;, informers.size());</span>

                // Perform initial cache load from all Informers, then mark sync complete
<span class="fc" id="L216">                Log.info(&quot;Performing initial cache load...&quot;);</span>
<span class="fc" id="L217">                reloadApplicationCache();</span>
<span class="fc" id="L218">                reloadBookmarkCache();</span>
<span class="fc" id="L219">                initialSyncComplete = true;</span>
<span class="fc" id="L220">                Log.info(&quot;Initial sync complete - Informers now active for real-time updates&quot;);</span>
<span class="nc" id="L221">              } catch (Exception e) {</span>
<span class="nc" id="L222">                Log.error(&quot;Failed to initialize Kubernetes Informer service&quot;, e);</span>
<span class="nc" id="L223">                Log.warn(&quot;Application will continue without Kubernetes resource watching&quot;);</span>
<span class="fc" id="L224">              }</span>
<span class="fc" id="L225">            },</span>
            &quot;informer-init&quot;)
<span class="fc" id="L227">        .start();</span>

<span class="fc" id="L229">    Log.info(&quot;Kubernetes Informer service initialization started in background&quot;);</span>
<span class="fc" id="L230">  }</span>

  /** Stops all informers on application shutdown. */
  void onStop(@Observes ShutdownEvent event) {
<span class="fc" id="L234">    Log.info(&quot;Stopping Kubernetes Informer service&quot;);</span>
<span class="fc" id="L235">    stopInformers();</span>
<span class="fc" id="L236">  }</span>

  /** Starts the Application CRD informer. */
  private void startApplicationInformer() {
    try {
<span class="fc" id="L241">      SharedIndexInformer&lt;Application&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L243">              .resources(Application.class)</span>
<span class="fc" id="L244">              .inAnyNamespace()</span>
<span class="fc" id="L245">              .inform(</span>
<span class="fc" id="L246">                  new ResourceEventHandler&lt;Application&gt;() {</span>
                    @Override
                    public void onAdd(Application application) {
<span class="fc" id="L249">                      handleApplicationAdded(application);</span>
<span class="fc" id="L250">                    }</span>

                    @Override
                    public void onUpdate(Application oldApp, Application newApp) {
<span class="fc" id="L254">                      handleApplicationUpdated(newApp);</span>
<span class="fc" id="L255">                    }</span>

                    @Override
                    public void onDelete(
                        Application application, boolean deletedFinalStateUnknown) {
<span class="fc" id="L260">                      handleApplicationDeleted(application);</span>
<span class="fc" id="L261">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L265">      informers.add(informer);</span>
<span class="fc" id="L266">      Log.info(&quot;Started Application CRD informer&quot;);</span>
<span class="nc" id="L267">    } catch (Exception e) {</span>
<span class="nc" id="L268">      Log.error(&quot;Failed to start Application informer&quot;, e);</span>
<span class="fc" id="L269">    }</span>
<span class="fc" id="L270">  }</span>

  /** Starts the Bookmark CRD informer. */
  private void startBookmarkInformer() {
    try {
<span class="fc" id="L275">      SharedIndexInformer&lt;Bookmark&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L277">              .resources(Bookmark.class)</span>
<span class="fc" id="L278">              .inAnyNamespace()</span>
<span class="fc" id="L279">              .inform(</span>
<span class="fc" id="L280">                  new ResourceEventHandler&lt;Bookmark&gt;() {</span>
                    @Override
                    public void onAdd(Bookmark bookmark) {
<span class="fc" id="L283">                      handleBookmarkAdded(bookmark);</span>
<span class="fc" id="L284">                    }</span>

                    @Override
                    public void onUpdate(Bookmark oldBookmark, Bookmark newBookmark) {
<span class="fc" id="L288">                      handleBookmarkUpdated(newBookmark);</span>
<span class="fc" id="L289">                    }</span>

                    @Override
                    public void onDelete(Bookmark bookmark, boolean deletedFinalStateUnknown) {
<span class="fc" id="L293">                      handleBookmarkDeleted(bookmark);</span>
<span class="fc" id="L294">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L298">      informers.add(informer);</span>
<span class="fc" id="L299">      Log.info(&quot;Started Bookmark CRD informer&quot;);</span>
<span class="nc" id="L300">    } catch (Exception e) {</span>
<span class="nc" id="L301">      Log.error(&quot;Failed to start Bookmark informer&quot;, e);</span>
<span class="fc" id="L302">    }</span>
<span class="fc" id="L303">  }</span>

  /** Starts the Hajimari Bookmark informer. */
  private void startHajimariBookmarkInformer() {
    try {
<span class="fc" id="L308">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L310">              .withGroup(&quot;hajimari.io&quot;)</span>
<span class="fc" id="L311">              .withVersion(&quot;v1alpha1&quot;)</span>
<span class="fc" id="L312">              .withPlural(&quot;bookmarks&quot;)</span>
<span class="fc" id="L313">              .withNamespaced(true)</span>
<span class="fc" id="L314">              .build();</span>

<span class="fc" id="L316">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L318">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L319">              .inAnyNamespace()</span>
<span class="fc" id="L320">              .inform(</span>
<span class="fc" id="L321">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L324" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L325">                        handleGenericBookmarkEvent(&quot;hajimari&quot;);</span>
                      }
<span class="nc" id="L327">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L334">                        handleGenericBookmarkEvent(&quot;hajimari&quot;);</span>
                      }
<span class="nc" id="L336">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L341" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L342">                        handleGenericBookmarkEvent(&quot;hajimari&quot;);</span>
                      }
<span class="nc" id="L344">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L348">      informers.add(informer);</span>
<span class="fc" id="L349">      Log.info(&quot;Started Hajimari Bookmark informer&quot;);</span>
<span class="nc" id="L350">    } catch (Exception e) {</span>
<span class="nc" id="L351">      Log.error(&quot;Failed to start Hajimari Bookmark informer&quot;, e);</span>
<span class="fc" id="L352">    }</span>
<span class="fc" id="L353">  }</span>

  /** Starts the Ingress informer. */
  private void startIngressInformer() {
    try {
<span class="fc" id="L358">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L360">              .withGroup(&quot;networking.k8s.io&quot;)</span>
<span class="fc" id="L361">              .withVersion(&quot;v1&quot;)</span>
<span class="fc" id="L362">              .withPlural(&quot;ingresses&quot;)</span>
<span class="fc" id="L363">              .withNamespaced(true)</span>
<span class="fc" id="L364">              .build();</span>

<span class="fc" id="L366">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L368">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L369">              .inAnyNamespace()</span>
<span class="fc" id="L370">              .inform(</span>
<span class="fc" id="L371">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L375">                        handleGenericApplicationEvent(&quot;ingress&quot;);</span>
                      }
<span class="nc" id="L377">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L383" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L384">                        handleGenericApplicationEvent(&quot;ingress&quot;);</span>
                      }
<span class="nc" id="L386">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L391" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L392">                        handleGenericApplicationEvent(&quot;ingress&quot;);</span>
                      }
<span class="nc" id="L394">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L398">      informers.add(informer);</span>
<span class="fc" id="L399">      Log.info(&quot;Started Ingress informer&quot;);</span>
<span class="nc" id="L400">    } catch (Exception e) {</span>
<span class="nc" id="L401">      Log.error(&quot;Failed to start Ingress informer&quot;, e);</span>
<span class="fc" id="L402">    }</span>
<span class="fc" id="L403">  }</span>

  /** Starts the OpenShift Route informer. */
  private void startRouteInformer() {
    try {
<span class="fc" id="L408">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L410">              .withGroup(&quot;route.openshift.io&quot;)</span>
<span class="fc" id="L411">              .withVersion(&quot;v1&quot;)</span>
<span class="fc" id="L412">              .withPlural(&quot;routes&quot;)</span>
<span class="fc" id="L413">              .withNamespaced(true)</span>
<span class="fc" id="L414">              .build();</span>

<span class="fc" id="L416">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L418">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L419">              .inAnyNamespace()</span>
<span class="fc" id="L420">              .inform(</span>
<span class="fc" id="L421">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L425">                        handleGenericApplicationEvent(&quot;route&quot;);</span>
                      }
<span class="nc" id="L427">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L433" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L434">                        handleGenericApplicationEvent(&quot;route&quot;);</span>
                      }
<span class="nc" id="L436">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L441" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L442">                        handleGenericApplicationEvent(&quot;route&quot;);</span>
                      }
<span class="nc" id="L444">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L448">      informers.add(informer);</span>
<span class="fc" id="L449">      Log.info(&quot;Started Route informer&quot;);</span>
<span class="fc" id="L450">    } catch (Exception e) {</span>
<span class="fc" id="L451">      Log.error(&quot;Failed to start Route informer&quot;, e);</span>
<span class="fc" id="L452">    }</span>
<span class="fc" id="L453">  }</span>

  /** Starts the Istio VirtualService informer. */
  private void startVirtualServiceInformer() {
    try {
<span class="fc" id="L458">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L460">              .withGroup(&quot;networking.istio.io&quot;)</span>
<span class="fc" id="L461">              .withVersion(&quot;v1&quot;)</span>
<span class="fc" id="L462">              .withPlural(&quot;virtualservices&quot;)</span>
<span class="fc" id="L463">              .withNamespaced(true)</span>
<span class="fc" id="L464">              .build();</span>

<span class="fc" id="L466">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L468">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L469">              .inAnyNamespace()</span>
<span class="fc" id="L470">              .inform(</span>
<span class="fc" id="L471">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L474" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L475">                        handleGenericApplicationEvent(&quot;virtualservice&quot;);</span>
                      }
<span class="nc" id="L477">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L484">                        handleGenericApplicationEvent(&quot;virtualservice&quot;);</span>
                      }
<span class="nc" id="L486">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L491" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L492">                        handleGenericApplicationEvent(&quot;virtualservice&quot;);</span>
                      }
<span class="nc" id="L494">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L498">      informers.add(informer);</span>
<span class="fc" id="L499">      Log.info(&quot;Started VirtualService informer&quot;);</span>
<span class="fc" id="L500">    } catch (Exception e) {</span>
<span class="fc" id="L501">      Log.error(&quot;Failed to start VirtualService informer&quot;, e);</span>
<span class="fc" id="L502">    }</span>
<span class="fc" id="L503">  }</span>

  /** Starts the Gateway API HTTPRoute informer. */
  private void startHttpRouteInformer() {
    try {
<span class="fc" id="L508">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L510">              .withGroup(&quot;gateway.networking.k8s.io&quot;)</span>
<span class="fc" id="L511">              .withVersion(&quot;v1&quot;)</span>
<span class="fc" id="L512">              .withPlural(&quot;httproutes&quot;)</span>
<span class="fc" id="L513">              .withNamespaced(true)</span>
<span class="fc" id="L514">              .build();</span>

<span class="fc" id="L516">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L518">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L519">              .inAnyNamespace()</span>
<span class="fc" id="L520">              .inform(</span>
<span class="fc" id="L521">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L524" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L525">                        handleGenericApplicationEvent(&quot;httproute&quot;);</span>
                      }
<span class="nc" id="L527">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L534">                        handleGenericApplicationEvent(&quot;httproute&quot;);</span>
                      }
<span class="nc" id="L536">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L541" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L542">                        handleGenericApplicationEvent(&quot;httproute&quot;);</span>
                      }
<span class="nc" id="L544">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L548">      informers.add(informer);</span>
<span class="fc" id="L549">      Log.info(&quot;Started HTTPRoute informer&quot;);</span>
<span class="fc" id="L550">    } catch (Exception e) {</span>
<span class="fc" id="L551">      Log.error(&quot;Failed to start HTTPRoute informer&quot;, e);</span>
<span class="fc" id="L552">    }</span>
<span class="fc" id="L553">  }</span>

  /** Handles Application CRD addition events. */
  private void handleApplicationAdded(Application application) {
<span class="pc bpc" id="L557" title="3 of 6 branches missed.">    if (application == null || application.getMetadata() == null || application.getSpec() == null) {</span>
<span class="nc" id="L558">      return;</span>
    }

    try {
<span class="fc" id="L562">      String namespace = application.getMetadata().getNamespace();</span>
<span class="fc" id="L563">      String name = application.getMetadata().getName();</span>

<span class="fc" id="L565">      Log.debugf(&quot;Application added: %s/%s&quot;, namespace, name);</span>

      // Create ApplicationResponse from spec
<span class="fc" id="L568">      ApplicationResponse appResponse = new ApplicationResponse(application.getSpec());</span>
<span class="fc" id="L569">      appResponse.setNamespace(namespace);</span>
<span class="fc" id="L570">      appResponse.setResourceName(name);</span>
<span class="fc" id="L571">      appResponse.setHasOwnerReferences(</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">          application.getMetadata().getOwnerReferences() != null</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">              &amp;&amp; !application.getMetadata().getOwnerReferences().isEmpty());</span>

      // Enrich with availability checking
<span class="fc" id="L576">      List&lt;ApplicationResponse&gt; enriched =</span>
<span class="fc" id="L577">          availabilityCheckService.enrichWithAvailability(List.of(appResponse));</span>

<span class="pc bpc" id="L579" title="1 of 2 branches missed.">      if (!enriched.isEmpty()) {</span>
<span class="fc" id="L580">        appResponse = enriched.get(0);</span>
      }

      // Register URL for availability checking
<span class="pc bpc" id="L584" title="1 of 4 branches missed.">      if (appResponse.getUrl() != null &amp;&amp; !appResponse.getUrl().isEmpty()) {</span>
<span class="fc" id="L585">        availabilityCheckService.registerUrl(appResponse.getUrl());</span>
      }

      // Store in cache
<span class="fc" id="L589">      applicationCacheService.put(appResponse);</span>

      // Broadcast event
<span class="fc" id="L592">      eventBroadcaster.broadcastApplicationAdded(application);</span>
<span class="nc" id="L593">    } catch (Exception e) {</span>
<span class="nc" id="L594">      Log.errorf(e, &quot;Error handling Application addition&quot;);</span>
<span class="fc" id="L595">    }</span>
<span class="fc" id="L596">  }</span>

  /** Handles Application CRD update events. */
  private void handleApplicationUpdated(Application application) {
<span class="pc bpc" id="L600" title="3 of 6 branches missed.">    if (application == null || application.getMetadata() == null || application.getSpec() == null) {</span>
<span class="nc" id="L601">      return;</span>
    }

    try {
<span class="fc" id="L605">      String namespace = application.getMetadata().getNamespace();</span>
<span class="fc" id="L606">      String name = application.getMetadata().getName();</span>

<span class="fc" id="L608">      Log.debugf(&quot;Application updated: %s/%s&quot;, namespace, name);</span>

      // Create ApplicationResponse from spec
<span class="fc" id="L611">      ApplicationResponse appResponse = new ApplicationResponse(application.getSpec());</span>
<span class="fc" id="L612">      appResponse.setNamespace(namespace);</span>
<span class="fc" id="L613">      appResponse.setResourceName(name);</span>
<span class="fc" id="L614">      appResponse.setHasOwnerReferences(</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">          application.getMetadata().getOwnerReferences() != null</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">              &amp;&amp; !application.getMetadata().getOwnerReferences().isEmpty());</span>

      // Enrich with availability checking
<span class="fc" id="L619">      List&lt;ApplicationResponse&gt; enriched =</span>
<span class="fc" id="L620">          availabilityCheckService.enrichWithAvailability(List.of(appResponse));</span>

<span class="pc bpc" id="L622" title="1 of 2 branches missed.">      if (!enriched.isEmpty()) {</span>
<span class="fc" id="L623">        appResponse = enriched.get(0);</span>
      }

      // Register URL for availability checking
<span class="pc bpc" id="L627" title="2 of 4 branches missed.">      if (appResponse.getUrl() != null &amp;&amp; !appResponse.getUrl().isEmpty()) {</span>
<span class="fc" id="L628">        availabilityCheckService.registerUrl(appResponse.getUrl());</span>
      }

      // Update in cache
<span class="fc" id="L632">      applicationCacheService.put(appResponse);</span>

      // Broadcast event
<span class="fc" id="L635">      eventBroadcaster.broadcastApplicationUpdated(application);</span>
<span class="nc" id="L636">    } catch (Exception e) {</span>
<span class="nc" id="L637">      Log.errorf(e, &quot;Error handling Application update&quot;);</span>
<span class="fc" id="L638">    }</span>
<span class="fc" id="L639">  }</span>

  /** Handles Application CRD deletion events. */
  private void handleApplicationDeleted(Application application) {
<span class="pc bpc" id="L643" title="2 of 4 branches missed.">    if (application == null || application.getMetadata() == null) {</span>
<span class="nc" id="L644">      return;</span>
    }

    try {
<span class="fc" id="L648">      String namespace = application.getMetadata().getNamespace();</span>
<span class="fc" id="L649">      String name = application.getMetadata().getName();</span>

<span class="fc" id="L651">      Log.debugf(&quot;Application deleted: %s/%s&quot;, namespace, name);</span>

      // Remove from cache
<span class="fc" id="L654">      ApplicationResponse removed = applicationCacheService.remove(namespace, name);</span>

      // Unregister URL from availability checking
<span class="pc bpc" id="L657" title="3 of 6 branches missed.">      if (removed != null &amp;&amp; removed.getUrl() != null &amp;&amp; !removed.getUrl().isEmpty()) {</span>
<span class="fc" id="L658">        availabilityCheckService.unregisterUrl(removed.getUrl());</span>
      }

      // Broadcast event
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">      if (removed != null) {</span>
<span class="fc" id="L663">        eventBroadcaster.broadcastApplicationRemoved(application);</span>
      }
<span class="nc" id="L665">    } catch (Exception e) {</span>
<span class="nc" id="L666">      Log.errorf(e, &quot;Error handling Application deletion&quot;);</span>
<span class="fc" id="L667">    }</span>
<span class="fc" id="L668">  }</span>

  /** Handles Bookmark CRD addition events. */
  private void handleBookmarkAdded(Bookmark bookmark) {
<span class="pc bpc" id="L672" title="3 of 6 branches missed.">    if (bookmark == null || bookmark.getMetadata() == null || bookmark.getSpec() == null) {</span>
<span class="nc" id="L673">      return;</span>
    }

    try {
<span class="fc" id="L677">      String namespace = bookmark.getMetadata().getNamespace();</span>
<span class="fc" id="L678">      String name = bookmark.getMetadata().getName();</span>

<span class="fc" id="L680">      Log.debugf(&quot;Bookmark added: %s/%s&quot;, namespace, name);</span>

      // Create BookmarkResponse from spec
<span class="fc" id="L683">      BookmarkResponse bookmarkResponse = new BookmarkResponse(bookmark.getSpec());</span>
<span class="fc" id="L684">      bookmarkResponse.setNamespace(namespace);</span>
<span class="fc" id="L685">      bookmarkResponse.setResourceName(name);</span>
<span class="fc" id="L686">      bookmarkResponse.setHasOwnerReferences(</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">          bookmark.getMetadata().getOwnerReferences() != null</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">              &amp;&amp; !bookmark.getMetadata().getOwnerReferences().isEmpty());</span>

      // Store in cache
<span class="fc" id="L691">      bookmarkCacheService.put(bookmarkResponse);</span>

      // Broadcast event
<span class="fc" id="L694">      eventBroadcaster.broadcastBookmarkAdded(bookmark);</span>
<span class="nc" id="L695">    } catch (Exception e) {</span>
<span class="nc" id="L696">      Log.errorf(e, &quot;Error handling Bookmark addition&quot;);</span>
<span class="fc" id="L697">    }</span>
<span class="fc" id="L698">  }</span>

  /** Handles Bookmark CRD update events. */
  private void handleBookmarkUpdated(Bookmark bookmark) {
<span class="pc bpc" id="L702" title="3 of 6 branches missed.">    if (bookmark == null || bookmark.getMetadata() == null || bookmark.getSpec() == null) {</span>
<span class="nc" id="L703">      return;</span>
    }

    try {
<span class="fc" id="L707">      String namespace = bookmark.getMetadata().getNamespace();</span>
<span class="fc" id="L708">      String name = bookmark.getMetadata().getName();</span>

<span class="fc" id="L710">      Log.debugf(&quot;Bookmark updated: %s/%s&quot;, namespace, name);</span>

      // Create BookmarkResponse from spec
<span class="fc" id="L713">      BookmarkResponse bookmarkResponse = new BookmarkResponse(bookmark.getSpec());</span>
<span class="fc" id="L714">      bookmarkResponse.setNamespace(namespace);</span>
<span class="fc" id="L715">      bookmarkResponse.setResourceName(name);</span>
<span class="fc" id="L716">      bookmarkResponse.setHasOwnerReferences(</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">          bookmark.getMetadata().getOwnerReferences() != null</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">              &amp;&amp; !bookmark.getMetadata().getOwnerReferences().isEmpty());</span>

      // Update in cache
<span class="fc" id="L721">      bookmarkCacheService.put(bookmarkResponse);</span>

      // Broadcast event
<span class="fc" id="L724">      eventBroadcaster.broadcastBookmarkUpdated(bookmark);</span>
<span class="nc" id="L725">    } catch (Exception e) {</span>
<span class="nc" id="L726">      Log.errorf(e, &quot;Error handling Bookmark update&quot;);</span>
<span class="fc" id="L727">    }</span>
<span class="fc" id="L728">  }</span>

  /** Handles Bookmark CRD deletion events. */
  private void handleBookmarkDeleted(Bookmark bookmark) {
<span class="pc bpc" id="L732" title="2 of 4 branches missed.">    if (bookmark == null || bookmark.getMetadata() == null) {</span>
<span class="nc" id="L733">      return;</span>
    }

    try {
<span class="fc" id="L737">      String namespace = bookmark.getMetadata().getNamespace();</span>
<span class="fc" id="L738">      String name = bookmark.getMetadata().getName();</span>

<span class="fc" id="L740">      Log.debugf(&quot;Bookmark deleted: %s/%s&quot;, namespace, name);</span>

      // Remove from cache
<span class="fc" id="L743">      BookmarkResponse removed = bookmarkCacheService.remove(namespace, name);</span>

      // Broadcast event
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">      if (removed != null) {</span>
<span class="fc" id="L747">        eventBroadcaster.broadcastBookmarkRemoved(bookmark);</span>
      }
<span class="nc" id="L749">    } catch (Exception e) {</span>
<span class="nc" id="L750">      Log.errorf(e, &quot;Error handling Bookmark deletion&quot;);</span>
<span class="fc" id="L751">    }</span>
<span class="fc" id="L752">  }</span>

  /**
   * Handles generic application resource events (Ingress, Route, VirtualService, HTTPRoute). For
   * generic resources, we reload all applications since we need to aggregate multiple resource
   * types.
   */
  private void handleGenericApplicationEvent(String resourceType) {
<span class="nc" id="L760">    Log.debugf(&quot;Generic application resource changed: %s, reloading applications&quot;, resourceType);</span>
<span class="nc" id="L761">    reloadApplicationCache();</span>
<span class="nc" id="L762">  }</span>

  /**
   * Handles generic bookmark resource events (Hajimari). For generic resources, we reload all
   * bookmarks.
   */
  private void handleGenericBookmarkEvent(String resourceType) {
<span class="nc" id="L769">    Log.debugf(&quot;Generic bookmark resource changed: %s, reloading bookmarks&quot;, resourceType);</span>
<span class="nc" id="L770">    reloadBookmarkCache();</span>
<span class="nc" id="L771">  }</span>

  /** Reloads the entire application cache from Kubernetes. */
  private void reloadApplicationCache() {
    try {
<span class="fc" id="L776">      Log.debug(&quot;Reloading application cache&quot;);</span>

<span class="fc" id="L778">      var applicationWrappers = new ArrayList&lt;BaseKubernetesObject&gt;();</span>
<span class="fc" id="L779">      applicationWrappers.add(new StartpunktApplicationWrapper());</span>

<span class="pc bpc" id="L781" title="2 of 4 branches missed.">      if (hajimariEnabled &amp;&amp; hajimariResourcesAvailable) {</span>
<span class="fc" id="L782">        applicationWrappers.add(new HajimariApplicationWrapper());</span>
      }
<span class="pc bpc" id="L784" title="1 of 4 branches missed.">      if (openshiftEnabled &amp;&amp; openshiftResourcesAvailable) {</span>
<span class="fc" id="L785">        applicationWrappers.add(new RouteApplicationWrapper(openshiftOnlyAnnotated));</span>
      }
<span class="pc bpc" id="L787" title="1 of 4 branches missed.">      if (ingressEnabled &amp;&amp; ingressResourcesAvailable) {</span>
<span class="fc" id="L788">        applicationWrappers.add(new IngressApplicationWrapper(ingressOnlyAnnotated));</span>
      }
<span class="pc bpc" id="L790" title="1 of 4 branches missed.">      if (istioVirtualServiceEnabled &amp;&amp; istioResourcesAvailable) {</span>
<span class="fc" id="L791">        applicationWrappers.add(</span>
            new IstioVirtualServiceApplicationWrapper(
                istioVirtualServiceOnlyAnnotated, defaultProtocol));
      }
<span class="pc bpc" id="L795" title="1 of 4 branches missed.">      if (gatewayApiEnabled &amp;&amp; gatewayApiResourcesAvailable) {</span>
<span class="fc" id="L796">        applicationWrappers.add(</span>
<span class="fc" id="L797">            new GatewayApiHttpRouteWrapper(gatewayApiHttpRouteOnlyAnnotated, defaultProtocol));</span>
      }

<span class="fc" id="L800">      var apps = new ArrayList&lt;ApplicationResponse&gt;();</span>

<span class="fc bfc" id="L802" title="All 2 branches covered.">      for (BaseKubernetesObject applicationWrapper : applicationWrappers) {</span>
<span class="fc" id="L803">        var wrapperApps =</span>
<span class="fc" id="L804">            applicationWrapper.getApplicationSpecsWithMetadata(</span>
<span class="fc" id="L805">                kubernetesClient, anyNamespace, matchNames.orElse(List.of()));</span>
<span class="fc" id="L806">        apps.addAll(wrapperApps);</span>
<span class="fc" id="L807">      }</span>

      // Register URLs for availability checking
<span class="fc bfc" id="L810" title="All 2 branches covered.">      for (ApplicationResponse app : apps) {</span>
<span class="pc bpc" id="L811" title="1 of 4 branches missed.">        if (app.getUrl() != null &amp;&amp; !app.getUrl().isEmpty()) {</span>
<span class="fc" id="L812">          availabilityCheckService.registerUrl(app.getUrl());</span>
        }
<span class="fc" id="L814">      }</span>

      // Sort and cache
<span class="fc" id="L817">      Collections.sort(apps);</span>

      // Clear and repopulate cache
<span class="fc" id="L820">      applicationCacheService.clear();</span>
<span class="fc" id="L821">      applicationCacheService.putAll(apps);</span>

      // Broadcast status change
<span class="fc" id="L824">      eventBroadcaster.broadcastStatusChanged(null);</span>

<span class="fc" id="L826">      Log.debugf(&quot;Reloaded %d applications into cache&quot;, apps.size());</span>
<span class="fc" id="L827">    } catch (Exception e) {</span>
<span class="fc" id="L828">      Log.error(&quot;Error reloading application cache&quot;, e);</span>
<span class="fc" id="L829">    }</span>
<span class="fc" id="L830">  }</span>

  /** Reloads the entire bookmark cache from Kubernetes. */
  private void reloadBookmarkCache() {
    try {
<span class="fc" id="L835">      Log.debug(&quot;Reloading bookmark cache&quot;);</span>

<span class="fc" id="L837">      List&lt;BookmarkResponse&gt; bookmarks = new ArrayList&lt;&gt;();</span>

      // Load Startpunkt bookmarks
<span class="fc" id="L840">      bookmarks.addAll(bookmarkService.retrieveBookmarks());</span>

      // Load Hajimari bookmarks if enabled and available
<span class="pc bpc" id="L843" title="2 of 4 branches missed.">      if (hajimariEnabled &amp;&amp; hajimariResourcesAvailable) {</span>
<span class="fc" id="L844">        bookmarks.addAll(bookmarkService.retrieveHajimariBookmarks());</span>
      }

      // Clear and repopulate cache
<span class="fc" id="L848">      bookmarkCacheService.clear();</span>
<span class="fc" id="L849">      bookmarkCacheService.putAll(bookmarks);</span>

      // Broadcast status change
<span class="fc" id="L852">      eventBroadcaster.broadcastStatusChanged(null);</span>

<span class="fc" id="L854">      Log.debugf(&quot;Reloaded %d bookmarks into cache&quot;, bookmarks.size());</span>
<span class="fc" id="L855">    } catch (Exception e) {</span>
<span class="fc" id="L856">      Log.error(&quot;Error reloading bookmark cache&quot;, e);</span>
<span class="fc" id="L857">    }</span>
<span class="fc" id="L858">  }</span>

  /** Stops all informers. */
  private void stopInformers() {
<span class="fc bfc" id="L862" title="All 2 branches covered.">    for (SharedIndexInformer&lt;?&gt; informer : informers) {</span>
      try {
<span class="fc" id="L864">        informer.stop();</span>
<span class="nc" id="L865">      } catch (Exception e) {</span>
<span class="nc" id="L866">        Log.warn(&quot;Error stopping informer&quot;, e);</span>
<span class="fc" id="L867">      }</span>
<span class="fc" id="L868">    }</span>
<span class="fc" id="L869">    informers.clear();</span>
<span class="fc" id="L870">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>