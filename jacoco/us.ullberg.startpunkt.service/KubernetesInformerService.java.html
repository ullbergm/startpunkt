<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KubernetesInformerService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">startpunkt</a> &gt; <a href="index.source.html" class="el_package">us.ullberg.startpunkt.service</a> &gt; <span class="el_source">KubernetesInformerService.java</span></div><h1>KubernetesInformerService.java</h1><pre class="source lang-java linenums">package us.ullberg.startpunkt.service;

import io.fabric8.kubernetes.api.model.GenericKubernetesResource;
import io.fabric8.kubernetes.client.KubernetesClient;
import io.fabric8.kubernetes.client.dsl.base.ResourceDefinitionContext;
import io.fabric8.kubernetes.client.informers.ResourceEventHandler;
import io.fabric8.kubernetes.client.informers.SharedIndexInformer;
import io.quarkus.logging.Log;
import io.quarkus.runtime.ShutdownEvent;
import io.quarkus.runtime.StartupEvent;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import us.ullberg.startpunkt.config.ClusterConfig;
import us.ullberg.startpunkt.crd.v1alpha4.Application;
import us.ullberg.startpunkt.crd.v1alpha4.Bookmark;
import us.ullberg.startpunkt.messaging.EventBroadcaster;
import us.ullberg.startpunkt.objects.ApplicationResponse;
import us.ullberg.startpunkt.objects.BookmarkResponse;
import us.ullberg.startpunkt.objects.kubernetes.BaseKubernetesObject;
import us.ullberg.startpunkt.objects.kubernetes.GatewayApiHttpRouteWrapper;
import us.ullberg.startpunkt.objects.kubernetes.HajimariApplicationWrapper;
import us.ullberg.startpunkt.objects.kubernetes.IngressApplicationWrapper;
import us.ullberg.startpunkt.objects.kubernetes.IstioVirtualServiceApplicationWrapper;
import us.ullberg.startpunkt.objects.kubernetes.RouteApplicationWrapper;
import us.ullberg.startpunkt.objects.kubernetes.StartpunktApplicationWrapper;

/**
 * Service that uses Kubernetes Informers to watch resources and maintain the application and
 * bookmark caches.
 *
 * &lt;p&gt;Informers provide automatic reconnection, resync, and resource version management, eliminating
 * the need for manual watch restart logic.
 *
 * &lt;p&gt;Informers are established for: - Application CRDs (startpunkt.ullberg.us) - Bookmark CRDs
 * (startpunkt.ullberg.us and hajimari.io) - Ingress resources (if enabled) - Route resources
 * (OpenShift, if enabled) - VirtualService resources (Istio, if enabled) - HTTPRoute resources
 * (Gateway API, if enabled)
 */
@ApplicationScoped
public class KubernetesInformerService {

  private final KubernetesClient kubernetesClient;
  private final MultiClusterService multiClusterService;
  private final ApplicationCacheService applicationCacheService;
  private final BookmarkCacheService bookmarkCacheService;
  private final EventBroadcaster eventBroadcaster;
  private final AvailabilityCheckService availabilityCheckService;
  private final BookmarkService bookmarkService;
  private final RemoteStartpunktClient remoteStartpunktClient;

  // List to hold all active informers for cleanup on shutdown
<span class="fc" id="L62">  private final List&lt;SharedIndexInformer&lt;?&gt;&gt; informers = new CopyOnWriteArrayList&lt;&gt;();</span>

  // Flag to suppress cache reload during initial sync
<span class="fc" id="L65">  private volatile boolean initialSyncComplete = false;</span>

  // Flags to track which resource types are available in the cluster
<span class="fc" id="L68">  private volatile boolean hajimariResourcesAvailable = false;</span>
<span class="fc" id="L69">  private volatile boolean ingressResourcesAvailable = false;</span>
<span class="fc" id="L70">  private volatile boolean openshiftResourcesAvailable = false;</span>
<span class="fc" id="L71">  private volatile boolean istioResourcesAvailable = false;</span>
<span class="fc" id="L72">  private volatile boolean gatewayApiResourcesAvailable = false;</span>

  // Track last reload time for debouncing cache reloads (prevent reload storms)
<span class="fc" id="L75">  private final Map&lt;String, Instant&gt; lastReloadTimes = new ConcurrentHashMap&lt;&gt;();</span>
  private static final long RELOAD_DEBOUNCE_MS = 500;

  @ConfigProperty(name = &quot;startpunkt.hajimari.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean hajimariEnabled;

  @ConfigProperty(name = &quot;startpunkt.ingress.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean ingressEnabled;

  @ConfigProperty(name = &quot;startpunkt.ingress.onlyAnnotated&quot;, defaultValue = &quot;true&quot;)
  boolean ingressOnlyAnnotated;

  @ConfigProperty(name = &quot;startpunkt.openshift.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean openshiftEnabled;

  @ConfigProperty(name = &quot;startpunkt.openshift.onlyAnnotated&quot;, defaultValue = &quot;true&quot;)
  boolean openshiftOnlyAnnotated;

  @ConfigProperty(name = &quot;startpunkt.istio.virtualservice.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean istioVirtualServiceEnabled;

  @ConfigProperty(name = &quot;startpunkt.istio.virtualservice.onlyAnnotated&quot;, defaultValue = &quot;true&quot;)
  boolean istioVirtualServiceOnlyAnnotated;

  @ConfigProperty(name = &quot;startpunkt.gatewayapi.httproute.enabled&quot;, defaultValue = &quot;false&quot;)
  boolean gatewayApiEnabled;

  @ConfigProperty(name = &quot;startpunkt.gatewayapi.httproute.onlyAnnotated&quot;, defaultValue = &quot;true&quot;)
  boolean gatewayApiHttpRouteOnlyAnnotated;

  @ConfigProperty(name = &quot;startpunkt.namespaceSelector.any&quot;, defaultValue = &quot;true&quot;)
  boolean anyNamespace;

  @ConfigProperty(name = &quot;startpunkt.namespaceSelector.matchNames&quot;)
  Optional&lt;List&lt;String&gt;&gt; matchNames;

  @ConfigProperty(name = &quot;startpunkt.defaultProtocol&quot;, defaultValue = &quot;http&quot;)
  String defaultProtocol;

  @ConfigProperty(name = &quot;startpunkt.watch.enabled&quot;, defaultValue = &quot;true&quot;)
  boolean watchEnabled;

  @ConfigProperty(name = &quot;startpunkt.watch.resyncPeriodSeconds&quot;, defaultValue = &quot;300&quot;)
  long resyncPeriodSeconds;

  /** Constructor with injected dependencies. */
  public KubernetesInformerService(
      KubernetesClient kubernetesClient,
      MultiClusterService multiClusterService,
      ApplicationCacheService applicationCacheService,
      BookmarkCacheService bookmarkCacheService,
      EventBroadcaster eventBroadcaster,
      AvailabilityCheckService availabilityCheckService,
      BookmarkService bookmarkService,
<span class="fc" id="L129">      RemoteStartpunktClient remoteStartpunktClient) {</span>
<span class="fc" id="L130">    this.kubernetesClient = kubernetesClient;</span>
<span class="fc" id="L131">    this.multiClusterService = multiClusterService;</span>
<span class="fc" id="L132">    this.applicationCacheService = applicationCacheService;</span>
<span class="fc" id="L133">    this.bookmarkCacheService = bookmarkCacheService;</span>
<span class="fc" id="L134">    this.eventBroadcaster = eventBroadcaster;</span>
<span class="fc" id="L135">    this.availabilityCheckService = availabilityCheckService;</span>
<span class="fc" id="L136">    this.bookmarkService = bookmarkService;</span>
<span class="fc" id="L137">    this.remoteStartpunktClient = remoteStartpunktClient;</span>
<span class="fc" id="L138">  }</span>

  /**
   * Checks if a resource type exists in the cluster by verifying the CRD or API resource.
   *
   * @param group the API group (e.g., &quot;networking.k8s.io&quot;)
   * @param version the API version (e.g., &quot;v1&quot;)
   * @param plural the plural resource name (e.g., &quot;ingresses&quot;)
   * @param resourceTypeName the friendly name for logging (e.g., &quot;Ingress&quot;)
   * @return true if the resource type exists, false otherwise
   */
  private boolean resourceTypeExists(
      String group, String version, String plural, String resourceTypeName) {
    try {
<span class="fc" id="L152">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L154">              .withGroup(group)</span>
<span class="fc" id="L155">              .withVersion(version)</span>
<span class="fc" id="L156">              .withPlural(plural)</span>
<span class="fc" id="L157">              .withNamespaced(true)</span>
<span class="fc" id="L158">              .build();</span>

      // Try to list resources to verify the type exists
<span class="fc" id="L161">      kubernetesClient.genericKubernetesResources(ctx).inAnyNamespace().list();</span>
<span class="fc" id="L162">      return true;</span>
<span class="fc" id="L163">    } catch (Exception e) {</span>
<span class="fc" id="L164">      Log.infof(</span>
          &quot;%s resources (%s/%s/%s) not available in cluster - skipping informer&quot;,
          resourceTypeName, group, version, plural);
<span class="fc" id="L167">      Log.debugf(e, &quot;Details for %s resource check&quot;, resourceTypeName);</span>
<span class="fc" id="L168">      return false;</span>
    }
  }

  /**
   * Initializes informers and starts watching Kubernetes resources on application startup.
   * Informers are started asynchronously to avoid blocking application startup.
   */
  void onStart(@Observes StartupEvent event) {
<span class="fc" id="L177">    Log.info(&quot;Initializing Kubernetes Informer service&quot;);</span>

<span class="pc bpc" id="L179" title="1 of 2 branches missed.">    if (!watchEnabled) {</span>
<span class="nc" id="L180">      Log.info(&quot;Kubernetes informers disabled by configuration&quot;);</span>
<span class="nc" id="L181">      return;</span>
    }

    // Start informers asynchronously to avoid blocking startup
    // This is especially important for native mode where K8s API may not be available
<span class="fc" id="L186">    new Thread(</span>
            () -&gt; {
              try {
                // Start informers for different resource types
<span class="fc" id="L190">                startApplicationInformer();</span>
<span class="fc" id="L191">                startBookmarkInformer();</span>

<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                if (hajimariEnabled</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">                    &amp;&amp; resourceTypeExists(</span>
                        &quot;hajimari.io&quot;, &quot;v1alpha1&quot;, &quot;bookmarks&quot;, &quot;Hajimari Bookmark&quot;)) {
<span class="fc" id="L196">                  hajimariResourcesAvailable = true;</span>
<span class="fc" id="L197">                  startHajimariBookmarkInformer();</span>
                }

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">                if (ingressEnabled</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">                    &amp;&amp; resourceTypeExists(&quot;networking.k8s.io&quot;, &quot;v1&quot;, &quot;ingresses&quot;, &quot;Ingress&quot;)) {</span>
<span class="fc" id="L202">                  ingressResourcesAvailable = true;</span>
<span class="fc" id="L203">                  startIngressInformer();</span>
                }

<span class="pc bpc" id="L206" title="1 of 2 branches missed.">                if (openshiftEnabled</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">                    &amp;&amp; resourceTypeExists(</span>
                        &quot;route.openshift.io&quot;, &quot;v1&quot;, &quot;routes&quot;, &quot;OpenShift Route&quot;)) {
<span class="fc" id="L209">                  openshiftResourcesAvailable = true;</span>
<span class="fc" id="L210">                  startRouteInformer();</span>
                }

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                if (istioVirtualServiceEnabled</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">                    &amp;&amp; resourceTypeExists(</span>
                        &quot;networking.istio.io&quot;, &quot;v1&quot;, &quot;virtualservices&quot;, &quot;Istio VirtualService&quot;)) {
<span class="fc" id="L216">                  istioResourcesAvailable = true;</span>
<span class="fc" id="L217">                  startVirtualServiceInformer();</span>
                }

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">                if (gatewayApiEnabled</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">                    &amp;&amp; resourceTypeExists(</span>
                        &quot;gateway.networking.k8s.io&quot;, &quot;v1&quot;, &quot;httproutes&quot;, &quot;Gateway API HTTPRoute&quot;)) {
<span class="fc" id="L223">                  gatewayApiResourcesAvailable = true;</span>
<span class="fc" id="L224">                  startHttpRouteInformer();</span>
                }

<span class="fc" id="L227">                Log.infof(</span>
<span class="fc" id="L228">                    &quot;Kubernetes Informer service initialized with %d informers&quot;, informers.size());</span>

                // Perform initial cache load from all Informers, then mark sync complete
<span class="fc" id="L231">                Log.info(&quot;Performing initial cache load...&quot;);</span>
<span class="fc" id="L232">                reloadApplicationCache();</span>
<span class="fc" id="L233">                reloadBookmarkCache();</span>
<span class="fc" id="L234">                initialSyncComplete = true;</span>
<span class="fc" id="L235">                Log.info(&quot;Initial sync complete - Informers now active for real-time updates&quot;);</span>
<span class="nc" id="L236">              } catch (Exception e) {</span>
<span class="nc" id="L237">                Log.error(&quot;Failed to initialize Kubernetes Informer service&quot;, e);</span>
<span class="nc" id="L238">                Log.warn(&quot;Application will continue without Kubernetes resource watching&quot;);</span>
<span class="fc" id="L239">              }</span>
<span class="fc" id="L240">            },</span>
            &quot;informer-init&quot;)
<span class="fc" id="L242">        .start();</span>

<span class="fc" id="L244">    Log.info(&quot;Kubernetes Informer service initialization started in background&quot;);</span>
<span class="fc" id="L245">  }</span>

  /** Stops all informers on application shutdown. */
  void onStop(@Observes ShutdownEvent event) {
<span class="fc" id="L249">    Log.info(&quot;Stopping Kubernetes Informer service&quot;);</span>
<span class="fc" id="L250">    stopInformers();</span>
<span class="fc" id="L251">  }</span>

  /** Starts the Application CRD informer. */
  private void startApplicationInformer() {
    try {
<span class="fc" id="L256">      SharedIndexInformer&lt;Application&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L258">              .resources(Application.class)</span>
<span class="fc" id="L259">              .inAnyNamespace()</span>
<span class="fc" id="L260">              .inform(</span>
<span class="fc" id="L261">                  new ResourceEventHandler&lt;Application&gt;() {</span>
                    @Override
                    public void onAdd(Application application) {
<span class="fc" id="L264">                      handleApplicationAdded(application);</span>
<span class="fc" id="L265">                    }</span>

                    @Override
                    public void onUpdate(Application oldApp, Application newApp) {
<span class="fc" id="L269">                      handleApplicationUpdated(oldApp, newApp);</span>
<span class="fc" id="L270">                    }</span>

                    @Override
                    public void onDelete(
                        Application application, boolean deletedFinalStateUnknown) {
<span class="fc" id="L275">                      handleApplicationDeleted(application);</span>
<span class="fc" id="L276">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L280">      informers.add(informer);</span>
<span class="fc" id="L281">      Log.info(&quot;Started Application CRD informer&quot;);</span>
<span class="nc" id="L282">    } catch (Exception e) {</span>
<span class="nc" id="L283">      Log.error(&quot;Failed to start Application informer&quot;, e);</span>
<span class="fc" id="L284">    }</span>
<span class="fc" id="L285">  }</span>

  /** Starts the Bookmark CRD informer. */
  private void startBookmarkInformer() {
    try {
<span class="fc" id="L290">      SharedIndexInformer&lt;Bookmark&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L292">              .resources(Bookmark.class)</span>
<span class="fc" id="L293">              .inAnyNamespace()</span>
<span class="fc" id="L294">              .inform(</span>
<span class="fc" id="L295">                  new ResourceEventHandler&lt;Bookmark&gt;() {</span>
                    @Override
                    public void onAdd(Bookmark bookmark) {
<span class="fc" id="L298">                      handleBookmarkAdded(bookmark);</span>
<span class="fc" id="L299">                    }</span>

                    @Override
                    public void onUpdate(Bookmark oldBookmark, Bookmark newBookmark) {
<span class="fc" id="L303">                      handleBookmarkUpdated(oldBookmark, newBookmark);</span>
<span class="fc" id="L304">                    }</span>

                    @Override
                    public void onDelete(Bookmark bookmark, boolean deletedFinalStateUnknown) {
<span class="fc" id="L308">                      handleBookmarkDeleted(bookmark);</span>
<span class="fc" id="L309">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L313">      informers.add(informer);</span>
<span class="fc" id="L314">      Log.info(&quot;Started Bookmark CRD informer&quot;);</span>
<span class="nc" id="L315">    } catch (Exception e) {</span>
<span class="nc" id="L316">      Log.error(&quot;Failed to start Bookmark informer&quot;, e);</span>
<span class="fc" id="L317">    }</span>
<span class="fc" id="L318">  }</span>

  /** Starts the Hajimari Bookmark informer. */
  private void startHajimariBookmarkInformer() {
    try {
<span class="fc" id="L323">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L325">              .withGroup(&quot;hajimari.io&quot;)</span>
<span class="fc" id="L326">              .withVersion(&quot;v1alpha1&quot;)</span>
<span class="fc" id="L327">              .withPlural(&quot;bookmarks&quot;)</span>
<span class="fc" id="L328">              .withNamespaced(true)</span>
<span class="fc" id="L329">              .build();</span>

<span class="fc" id="L331">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L333">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L334">              .inAnyNamespace()</span>
<span class="fc" id="L335">              .inform(</span>
<span class="fc" id="L336">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L339" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L340">                        handleGenericBookmarkEvent(&quot;hajimari&quot;);</span>
                      }
<span class="nc" id="L342">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L348" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L349">                        handleGenericBookmarkEvent(&quot;hajimari&quot;);</span>
                      }
<span class="nc" id="L351">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L356" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L357">                        handleGenericBookmarkEvent(&quot;hajimari&quot;);</span>
                      }
<span class="nc" id="L359">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L363">      informers.add(informer);</span>
<span class="fc" id="L364">      Log.info(&quot;Started Hajimari Bookmark informer&quot;);</span>
<span class="fc" id="L365">    } catch (Exception e) {</span>
<span class="fc" id="L366">      Log.error(&quot;Failed to start Hajimari Bookmark informer&quot;, e);</span>
<span class="fc" id="L367">    }</span>
<span class="fc" id="L368">  }</span>

  /** Starts the Ingress informer. */
  private void startIngressInformer() {
    try {
<span class="fc" id="L373">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L375">              .withGroup(&quot;networking.k8s.io&quot;)</span>
<span class="fc" id="L376">              .withVersion(&quot;v1&quot;)</span>
<span class="fc" id="L377">              .withPlural(&quot;ingresses&quot;)</span>
<span class="fc" id="L378">              .withNamespaced(true)</span>
<span class="fc" id="L379">              .build();</span>

<span class="fc" id="L381">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L383">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L384">              .inAnyNamespace()</span>
<span class="fc" id="L385">              .inform(</span>
<span class="fc" id="L386">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L389" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L390">                        handleGenericApplicationEvent(&quot;ingress&quot;);</span>
                      }
<span class="nc" id="L392">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L399">                        handleGenericApplicationEvent(&quot;ingress&quot;);</span>
                      }
<span class="nc" id="L401">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L407">                        handleGenericApplicationEvent(&quot;ingress&quot;);</span>
                      }
<span class="nc" id="L409">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L413">      informers.add(informer);</span>
<span class="fc" id="L414">      Log.info(&quot;Started Ingress informer&quot;);</span>
<span class="nc" id="L415">    } catch (Exception e) {</span>
<span class="nc" id="L416">      Log.error(&quot;Failed to start Ingress informer&quot;, e);</span>
<span class="fc" id="L417">    }</span>
<span class="fc" id="L418">  }</span>

  /** Starts the OpenShift Route informer. */
  private void startRouteInformer() {
    try {
<span class="fc" id="L423">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L425">              .withGroup(&quot;route.openshift.io&quot;)</span>
<span class="fc" id="L426">              .withVersion(&quot;v1&quot;)</span>
<span class="fc" id="L427">              .withPlural(&quot;routes&quot;)</span>
<span class="fc" id="L428">              .withNamespaced(true)</span>
<span class="fc" id="L429">              .build();</span>

<span class="fc" id="L431">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L433">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L434">              .inAnyNamespace()</span>
<span class="fc" id="L435">              .inform(</span>
<span class="fc" id="L436">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L439" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L440">                        handleGenericApplicationEvent(&quot;route&quot;);</span>
                      }
<span class="nc" id="L442">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L448" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L449">                        handleGenericApplicationEvent(&quot;route&quot;);</span>
                      }
<span class="nc" id="L451">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L456" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L457">                        handleGenericApplicationEvent(&quot;route&quot;);</span>
                      }
<span class="nc" id="L459">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L463">      informers.add(informer);</span>
<span class="fc" id="L464">      Log.info(&quot;Started Route informer&quot;);</span>
<span class="nc" id="L465">    } catch (Exception e) {</span>
<span class="nc" id="L466">      Log.error(&quot;Failed to start Route informer&quot;, e);</span>
<span class="fc" id="L467">    }</span>
<span class="fc" id="L468">  }</span>

  /** Starts the Istio VirtualService informer. */
  private void startVirtualServiceInformer() {
    try {
<span class="fc" id="L473">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L475">              .withGroup(&quot;networking.istio.io&quot;)</span>
<span class="fc" id="L476">              .withVersion(&quot;v1&quot;)</span>
<span class="fc" id="L477">              .withPlural(&quot;virtualservices&quot;)</span>
<span class="fc" id="L478">              .withNamespaced(true)</span>
<span class="fc" id="L479">              .build();</span>

<span class="fc" id="L481">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L483">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L484">              .inAnyNamespace()</span>
<span class="fc" id="L485">              .inform(</span>
<span class="fc" id="L486">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L489" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L490">                        handleGenericApplicationEvent(&quot;virtualservice&quot;);</span>
                      }
<span class="nc" id="L492">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L498" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L499">                        handleGenericApplicationEvent(&quot;virtualservice&quot;);</span>
                      }
<span class="nc" id="L501">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L506" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L507">                        handleGenericApplicationEvent(&quot;virtualservice&quot;);</span>
                      }
<span class="nc" id="L509">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L513">      informers.add(informer);</span>
<span class="fc" id="L514">      Log.info(&quot;Started VirtualService informer&quot;);</span>
<span class="nc" id="L515">    } catch (Exception e) {</span>
<span class="nc" id="L516">      Log.error(&quot;Failed to start VirtualService informer&quot;, e);</span>
<span class="fc" id="L517">    }</span>
<span class="fc" id="L518">  }</span>

  /** Starts the Gateway API HTTPRoute informer. */
  private void startHttpRouteInformer() {
    try {
<span class="fc" id="L523">      ResourceDefinitionContext ctx =</span>
          new ResourceDefinitionContext.Builder()
<span class="fc" id="L525">              .withGroup(&quot;gateway.networking.k8s.io&quot;)</span>
<span class="fc" id="L526">              .withVersion(&quot;v1&quot;)</span>
<span class="fc" id="L527">              .withPlural(&quot;httproutes&quot;)</span>
<span class="fc" id="L528">              .withNamespaced(true)</span>
<span class="fc" id="L529">              .build();</span>

<span class="fc" id="L531">      SharedIndexInformer&lt;GenericKubernetesResource&gt; informer =</span>
          kubernetesClient
<span class="fc" id="L533">              .genericKubernetesResources(ctx)</span>
<span class="fc" id="L534">              .inAnyNamespace()</span>
<span class="fc" id="L535">              .inform(</span>
<span class="fc" id="L536">                  new ResourceEventHandler&lt;GenericKubernetesResource&gt;() {</span>
                    @Override
                    public void onAdd(GenericKubernetesResource resource) {
<span class="nc bnc" id="L539" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L540">                        handleGenericApplicationEvent(&quot;httproute&quot;);</span>
                      }
<span class="nc" id="L542">                    }</span>

                    @Override
                    public void onUpdate(
                        GenericKubernetesResource oldResource,
                        GenericKubernetesResource newResource) {
<span class="nc bnc" id="L548" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L549">                        handleGenericApplicationEvent(&quot;httproute&quot;);</span>
                      }
<span class="nc" id="L551">                    }</span>

                    @Override
                    public void onDelete(
                        GenericKubernetesResource resource, boolean deletedFinalStateUnknown) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">                      if (initialSyncComplete) {</span>
<span class="nc" id="L557">                        handleGenericApplicationEvent(&quot;httproute&quot;);</span>
                      }
<span class="nc" id="L559">                    }</span>
                  },
                  resyncPeriodSeconds * 1000);

<span class="fc" id="L563">      informers.add(informer);</span>
<span class="fc" id="L564">      Log.info(&quot;Started HTTPRoute informer&quot;);</span>
<span class="fc" id="L565">    } catch (Exception e) {</span>
<span class="fc" id="L566">      Log.error(&quot;Failed to start HTTPRoute informer&quot;, e);</span>
<span class="fc" id="L567">    }</span>
<span class="fc" id="L568">  }</span>

  /** Handles Application CRD addition events. */
  private void handleApplicationAdded(Application application) {
<span class="pc bpc" id="L572" title="3 of 6 branches missed.">    if (application == null || application.getMetadata() == null || application.getSpec() == null) {</span>
<span class="nc" id="L573">      return;</span>
    }

    try {
<span class="fc" id="L577">      String namespace = application.getMetadata().getNamespace();</span>
<span class="fc" id="L578">      String name = application.getMetadata().getName();</span>

<span class="fc" id="L580">      Log.debugf(&quot;Application added: %s/%s&quot;, namespace, name);</span>

      // Create ApplicationResponse from spec
<span class="fc" id="L583">      ApplicationResponse appResponse = new ApplicationResponse(application.getSpec());</span>
<span class="fc" id="L584">      appResponse.setNamespace(namespace);</span>
<span class="fc" id="L585">      appResponse.setResourceName(name);</span>
<span class="fc" id="L586">      appResponse.setHasOwnerReferences(</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">          application.getMetadata().getOwnerReferences() != null</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">              &amp;&amp; !application.getMetadata().getOwnerReferences().isEmpty());</span>

      // Enrich with availability checking
<span class="fc" id="L591">      List&lt;ApplicationResponse&gt; enriched =</span>
<span class="fc" id="L592">          availabilityCheckService.enrichWithAvailability(List.of(appResponse));</span>

<span class="pc bpc" id="L594" title="1 of 2 branches missed.">      if (!enriched.isEmpty()) {</span>
<span class="fc" id="L595">        appResponse = enriched.get(0);</span>
      }

      // Register URL for availability checking
<span class="pc bpc" id="L599" title="1 of 4 branches missed.">      if (appResponse.getUrl() != null &amp;&amp; !appResponse.getUrl().isEmpty()) {</span>
<span class="fc" id="L600">        availabilityCheckService.registerUrl(appResponse.getUrl());</span>
      }

      // Store in cache
<span class="fc" id="L604">      applicationCacheService.put(appResponse);</span>

      // Broadcast event
<span class="fc" id="L607">      eventBroadcaster.broadcastApplicationAdded(application);</span>
<span class="nc" id="L608">    } catch (Exception e) {</span>
<span class="nc" id="L609">      Log.errorf(e, &quot;Error handling Application addition&quot;);</span>
<span class="fc" id="L610">    }</span>
<span class="fc" id="L611">  }</span>

  /** Handles Application CRD update events. */
  private void handleApplicationUpdated(Application oldApp, Application newApp) {
<span class="pc bpc" id="L615" title="3 of 6 branches missed.">    if (newApp == null || newApp.getMetadata() == null || newApp.getSpec() == null) {</span>
<span class="nc" id="L616">      return;</span>
    }

    // Skip updates that don't affect spec or relevant annotations (e.g., status changes)
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">    if (!isApplicationUpdateMeaningful(oldApp, newApp)) {</span>
<span class="nc" id="L621">      String namespace = newApp.getMetadata().getNamespace();</span>
<span class="nc" id="L622">      String name = newApp.getMetadata().getName();</span>
<span class="nc" id="L623">      Log.debugf(&quot;Skipping Application update (no meaningful changes): %s/%s&quot;, namespace, name);</span>
<span class="nc" id="L624">      return;</span>
    }

    try {
<span class="fc" id="L628">      String namespace = newApp.getMetadata().getNamespace();</span>
<span class="fc" id="L629">      String name = newApp.getMetadata().getName();</span>

<span class="fc" id="L631">      Log.debugf(&quot;Application updated: %s/%s&quot;, namespace, name);</span>

      // Create ApplicationResponse from spec
<span class="fc" id="L634">      ApplicationResponse appResponse = new ApplicationResponse(newApp.getSpec());</span>
<span class="fc" id="L635">      appResponse.setNamespace(namespace);</span>
<span class="fc" id="L636">      appResponse.setResourceName(name);</span>
<span class="fc" id="L637">      appResponse.setHasOwnerReferences(</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">          newApp.getMetadata().getOwnerReferences() != null</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">              &amp;&amp; !newApp.getMetadata().getOwnerReferences().isEmpty());</span>

      // Enrich with availability checking
<span class="fc" id="L642">      List&lt;ApplicationResponse&gt; enriched =</span>
<span class="fc" id="L643">          availabilityCheckService.enrichWithAvailability(List.of(appResponse));</span>

<span class="pc bpc" id="L645" title="1 of 2 branches missed.">      if (!enriched.isEmpty()) {</span>
<span class="fc" id="L646">        appResponse = enriched.get(0);</span>
      }

      // Register URL for availability checking
<span class="pc bpc" id="L650" title="2 of 4 branches missed.">      if (appResponse.getUrl() != null &amp;&amp; !appResponse.getUrl().isEmpty()) {</span>
<span class="fc" id="L651">        availabilityCheckService.registerUrl(appResponse.getUrl());</span>
      }

      // Update in cache
<span class="fc" id="L655">      applicationCacheService.put(appResponse);</span>

      // Broadcast event
<span class="fc" id="L658">      eventBroadcaster.broadcastApplicationUpdated(newApp);</span>
<span class="nc" id="L659">    } catch (Exception e) {</span>
<span class="nc" id="L660">      Log.errorf(e, &quot;Error handling Application update&quot;);</span>
<span class="fc" id="L661">    }</span>
<span class="fc" id="L662">  }</span>

  /** Handles Application CRD deletion events. */
  private void handleApplicationDeleted(Application application) {
<span class="pc bpc" id="L666" title="2 of 4 branches missed.">    if (application == null || application.getMetadata() == null) {</span>
<span class="nc" id="L667">      return;</span>
    }

    try {
<span class="fc" id="L671">      String namespace = application.getMetadata().getNamespace();</span>
<span class="fc" id="L672">      String name = application.getMetadata().getName();</span>

<span class="fc" id="L674">      Log.debugf(&quot;Application deleted: %s/%s&quot;, namespace, name);</span>

      // Remove from cache (assuming local cluster for now)
<span class="fc" id="L677">      ApplicationResponse removed = applicationCacheService.remove(&quot;local&quot;, namespace, name);</span>

      // Unregister URL from availability checking
<span class="pc bpc" id="L680" title="3 of 6 branches missed.">      if (removed != null &amp;&amp; removed.getUrl() != null &amp;&amp; !removed.getUrl().isEmpty()) {</span>
<span class="fc" id="L681">        availabilityCheckService.unregisterUrl(removed.getUrl());</span>
      }

      // Broadcast event
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">      if (removed != null) {</span>
<span class="fc" id="L686">        eventBroadcaster.broadcastApplicationRemoved(application);</span>
      }
<span class="nc" id="L688">    } catch (Exception e) {</span>
<span class="nc" id="L689">      Log.errorf(e, &quot;Error handling Application deletion&quot;);</span>
<span class="fc" id="L690">    }</span>
<span class="fc" id="L691">  }</span>

  /** Handles Bookmark CRD addition events. */
  private void handleBookmarkAdded(Bookmark bookmark) {
<span class="pc bpc" id="L695" title="3 of 6 branches missed.">    if (bookmark == null || bookmark.getMetadata() == null || bookmark.getSpec() == null) {</span>
<span class="nc" id="L696">      return;</span>
    }

    try {
<span class="fc" id="L700">      String namespace = bookmark.getMetadata().getNamespace();</span>
<span class="fc" id="L701">      String name = bookmark.getMetadata().getName();</span>

<span class="fc" id="L703">      Log.debugf(&quot;Bookmark added: %s/%s&quot;, namespace, name);</span>

      // Create BookmarkResponse from spec
<span class="fc" id="L706">      BookmarkResponse bookmarkResponse = new BookmarkResponse(bookmark.getSpec());</span>
<span class="fc" id="L707">      bookmarkResponse.setNamespace(namespace);</span>
<span class="fc" id="L708">      bookmarkResponse.setResourceName(name);</span>
<span class="fc" id="L709">      bookmarkResponse.setHasOwnerReferences(</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">          bookmark.getMetadata().getOwnerReferences() != null</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">              &amp;&amp; !bookmark.getMetadata().getOwnerReferences().isEmpty());</span>

      // Store in cache
<span class="fc" id="L714">      bookmarkCacheService.put(bookmarkResponse);</span>

      // Broadcast event
<span class="fc" id="L717">      eventBroadcaster.broadcastBookmarkAdded(bookmark);</span>
<span class="nc" id="L718">    } catch (Exception e) {</span>
<span class="nc" id="L719">      Log.errorf(e, &quot;Error handling Bookmark addition&quot;);</span>
<span class="fc" id="L720">    }</span>
<span class="fc" id="L721">  }</span>

  /** Handles Bookmark CRD update events. */
  private void handleBookmarkUpdated(Bookmark oldBookmark, Bookmark newBookmark) {
<span class="pc bpc" id="L725" title="3 of 6 branches missed.">    if (newBookmark == null || newBookmark.getMetadata() == null || newBookmark.getSpec() == null) {</span>
<span class="nc" id="L726">      return;</span>
    }

    // Skip updates that don't affect spec or relevant annotations (e.g., status changes)
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">    if (!isBookmarkUpdateMeaningful(oldBookmark, newBookmark)) {</span>
<span class="nc" id="L731">      String namespace = newBookmark.getMetadata().getNamespace();</span>
<span class="nc" id="L732">      String name = newBookmark.getMetadata().getName();</span>
<span class="nc" id="L733">      Log.debugf(&quot;Skipping Bookmark update (no meaningful changes): %s/%s&quot;, namespace, name);</span>
<span class="nc" id="L734">      return;</span>
    }

    try {
<span class="fc" id="L738">      String namespace = newBookmark.getMetadata().getNamespace();</span>
<span class="fc" id="L739">      String name = newBookmark.getMetadata().getName();</span>

<span class="fc" id="L741">      Log.debugf(&quot;Bookmark updated: %s/%s&quot;, namespace, name);</span>

      // Create BookmarkResponse from spec
<span class="fc" id="L744">      BookmarkResponse bookmarkResponse = new BookmarkResponse(newBookmark.getSpec());</span>
<span class="fc" id="L745">      bookmarkResponse.setNamespace(namespace);</span>
<span class="fc" id="L746">      bookmarkResponse.setResourceName(name);</span>
<span class="fc" id="L747">      bookmarkResponse.setHasOwnerReferences(</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">          newBookmark.getMetadata().getOwnerReferences() != null</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">              &amp;&amp; !newBookmark.getMetadata().getOwnerReferences().isEmpty());</span>

      // Update in cache
<span class="fc" id="L752">      bookmarkCacheService.put(bookmarkResponse);</span>

      // Broadcast event
<span class="fc" id="L755">      eventBroadcaster.broadcastBookmarkUpdated(newBookmark);</span>
<span class="nc" id="L756">    } catch (Exception e) {</span>
<span class="nc" id="L757">      Log.errorf(e, &quot;Error handling Bookmark update&quot;);</span>
<span class="fc" id="L758">    }</span>
<span class="fc" id="L759">  }</span>

  /** Handles Bookmark CRD deletion events. */
  private void handleBookmarkDeleted(Bookmark bookmark) {
<span class="pc bpc" id="L763" title="2 of 4 branches missed.">    if (bookmark == null || bookmark.getMetadata() == null) {</span>
<span class="nc" id="L764">      return;</span>
    }

    try {
<span class="fc" id="L768">      String namespace = bookmark.getMetadata().getNamespace();</span>
<span class="fc" id="L769">      String name = bookmark.getMetadata().getName();</span>

<span class="fc" id="L771">      Log.debugf(&quot;Bookmark deleted: %s/%s&quot;, namespace, name);</span>

      // Remove from cache (assuming local cluster for now)
<span class="fc" id="L774">      BookmarkResponse removed = bookmarkCacheService.remove(&quot;local&quot;, namespace, name);</span>

      // Broadcast event
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">      if (removed != null) {</span>
<span class="fc" id="L778">        eventBroadcaster.broadcastBookmarkRemoved(bookmark);</span>
      }
<span class="nc" id="L780">    } catch (Exception e) {</span>
<span class="nc" id="L781">      Log.errorf(e, &quot;Error handling Bookmark deletion&quot;);</span>
<span class="fc" id="L782">    }</span>
<span class="fc" id="L783">  }</span>

  /**
   * Checks if a reload should be debounced to prevent reload storms.
   *
   * @param eventKey the unique key for the event type
   * @return true if the reload should be debounced, false otherwise
   */
  private boolean shouldDebounceReload(String eventKey) {
<span class="nc" id="L792">    Instant lastReload = lastReloadTimes.get(eventKey);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">    if (lastReload == null) {</span>
<span class="nc" id="L794">      lastReloadTimes.put(eventKey, Instant.now());</span>
<span class="nc" id="L795">      return false;</span>
    }

<span class="nc" id="L798">    Duration timeSinceLastReload = Duration.between(lastReload, Instant.now());</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">    if (timeSinceLastReload.toMillis() &lt; RELOAD_DEBOUNCE_MS) {</span>
<span class="nc" id="L800">      return true;</span>
    }

<span class="nc" id="L803">    lastReloadTimes.put(eventKey, Instant.now());</span>
<span class="nc" id="L804">    return false;</span>
  }

  /**
   * Checks if an Application CRD update represents a meaningful change that requires cache reload.
   * Only changes to spec or Startpunkt/Hajimari/Forecastle annotations matter.
   *
   * @param oldApp the old application
   * @param newApp the new application
   * @return true if the update is meaningful, false if it's only status/metadata
   */
  private boolean isApplicationUpdateMeaningful(Application oldApp, Application newApp) {
<span class="pc bpc" id="L816" title="2 of 4 branches missed.">    if (oldApp == null || newApp == null) {</span>
<span class="nc" id="L817">      return true;</span>
    }

    // Check if spec changed
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">    if (!java.util.Objects.equals(oldApp.getSpec(), newApp.getSpec())) {</span>
<span class="fc" id="L822">      return true;</span>
    }

    // Check if relevant annotations changed
<span class="nc" id="L826">    return hasRelevantAnnotationChanges(</span>
<span class="nc" id="L827">        oldApp.getMetadata().getAnnotations(), newApp.getMetadata().getAnnotations());</span>
  }

  /**
   * Checks if a Bookmark CRD update represents a meaningful change that requires cache reload. Only
   * changes to spec or Startpunkt/Hajimari annotations matter.
   *
   * @param oldBookmark the old bookmark
   * @param newBookmark the new bookmark
   * @return true if the update is meaningful, false if it's only status/metadata
   */
  private boolean isBookmarkUpdateMeaningful(Bookmark oldBookmark, Bookmark newBookmark) {
<span class="pc bpc" id="L839" title="2 of 4 branches missed.">    if (oldBookmark == null || newBookmark == null) {</span>
<span class="nc" id="L840">      return true;</span>
    }

    // Check if spec changed
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">    if (!java.util.Objects.equals(oldBookmark.getSpec(), newBookmark.getSpec())) {</span>
<span class="fc" id="L845">      return true;</span>
    }

    // Check if relevant annotations changed
<span class="nc" id="L849">    return hasRelevantAnnotationChanges(</span>
<span class="nc" id="L850">        oldBookmark.getMetadata().getAnnotations(), newBookmark.getMetadata().getAnnotations());</span>
  }

  /**
   * Checks if relevant annotations (startpunkt.ullberg.us/*, hajimari.io/*,
   * forecastle.stakater.com/*) have changed.
   *
   * @param oldAnnotations the old annotations map
   * @param newAnnotations the new annotations map
   * @return true if relevant annotations changed
   */
  private boolean hasRelevantAnnotationChanges(
      Map&lt;String, String&gt; oldAnnotations, Map&lt;String, String&gt; newAnnotations) {
<span class="nc bnc" id="L863" title="All 2 branches missed.">    if (oldAnnotations == null) {</span>
<span class="nc" id="L864">      oldAnnotations = Map.of();</span>
    }
<span class="nc bnc" id="L866" title="All 2 branches missed.">    if (newAnnotations == null) {</span>
<span class="nc" id="L867">      newAnnotations = Map.of();</span>
    }

    // Prefixes we care about
<span class="nc" id="L871">    String[] relevantPrefixes = {</span>
      &quot;startpunkt.ullberg.us/&quot;, &quot;hajimari.io/&quot;, &quot;forecastle.stakater.com/&quot;
    };

    // Collect all relevant annotation keys from both old and new
<span class="nc" id="L876">    var relevantKeys = new java.util.HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">    for (String key : oldAnnotations.keySet()) {</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">      for (String prefix : relevantPrefixes) {</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (key.startsWith(prefix)) {</span>
<span class="nc" id="L880">          relevantKeys.add(key);</span>
<span class="nc" id="L881">          break;</span>
        }
      }
<span class="nc" id="L884">    }</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">    for (String key : newAnnotations.keySet()) {</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">      for (String prefix : relevantPrefixes) {</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">        if (key.startsWith(prefix)) {</span>
<span class="nc" id="L888">          relevantKeys.add(key);</span>
<span class="nc" id="L889">          break;</span>
        }
      }
<span class="nc" id="L892">    }</span>

    // Check if any relevant annotation changed
<span class="nc bnc" id="L895" title="All 2 branches missed.">    for (String key : relevantKeys) {</span>
<span class="nc" id="L896">      String oldValue = oldAnnotations.get(key);</span>
<span class="nc" id="L897">      String newValue = newAnnotations.get(key);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">      if (!java.util.Objects.equals(oldValue, newValue)) {</span>
<span class="nc" id="L899">        return true;</span>
      }
<span class="nc" id="L901">    }</span>

<span class="nc" id="L903">    return false;</span>
  }

  /**
   * Handles generic application resource events (Ingress, Route, VirtualService, HTTPRoute). For
   * generic resources, we reload all applications since we need to aggregate multiple resource
   * types.
   */
  private void handleGenericApplicationEvent(String resourceType) {
<span class="nc" id="L912">    String eventKey = &quot;GENERIC_APP_&quot; + resourceType;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">    if (shouldDebounceReload(eventKey)) {</span>
<span class="nc" id="L914">      Log.debugf(&quot;Debouncing generic application event: %s&quot;, resourceType);</span>
<span class="nc" id="L915">      return;</span>
    }

<span class="nc" id="L918">    Log.debugf(&quot;Generic application resource changed: %s, reloading applications&quot;, resourceType);</span>
<span class="nc" id="L919">    reloadApplicationCache();</span>
<span class="nc" id="L920">  }</span>

  /**
   * Handles generic bookmark resource events (Hajimari). For generic resources, we reload all
   * bookmarks.
   */
  private void handleGenericBookmarkEvent(String resourceType) {
<span class="nc" id="L927">    String eventKey = &quot;GENERIC_BOOKMARK_&quot; + resourceType;</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">    if (shouldDebounceReload(eventKey)) {</span>
<span class="nc" id="L929">      Log.debugf(&quot;Debouncing generic bookmark event: %s&quot;, resourceType);</span>
<span class="nc" id="L930">      return;</span>
    }

<span class="nc" id="L933">    Log.debugf(&quot;Generic bookmark resource changed: %s, reloading bookmarks&quot;, resourceType);</span>
<span class="nc" id="L934">    reloadBookmarkCache();</span>
<span class="nc" id="L935">  }</span>

  /** Reloads the entire application cache from Kubernetes. */
  private void reloadApplicationCache() {
    try {
<span class="fc" id="L940">      Log.debug(&quot;Reloading application cache&quot;);</span>

<span class="fc" id="L942">      var apps = new ArrayList&lt;ApplicationResponse&gt;();</span>

      // Iterate through all active clusters
<span class="fc bfc" id="L945" title="All 2 branches covered.">      for (String clusterName : multiClusterService.getActiveClusterNames()) {</span>
<span class="fc" id="L946">        Log.infof(&quot;Processing cluster: %s&quot;, clusterName);</span>
<span class="fc" id="L947">        Optional&lt;ClusterConfig&gt; configOpt = multiClusterService.getClusterConfig(clusterName);</span>

        // Check if this is a remote GraphQL cluster (not local)
<span class="pc bpc" id="L950" title="3 of 4 branches missed.">        if (configOpt.isPresent() &amp;&amp; !&quot;local&quot;.equalsIgnoreCase(clusterName)) {</span>
<span class="nc" id="L951">          Log.infof(&quot;Loading applications from remote Startpunkt '%s' via GraphQL&quot;, clusterName);</span>
          try {
<span class="nc" id="L953">            List&lt;ApplicationResponse&gt; remoteApps =</span>
<span class="nc" id="L954">                remoteStartpunktClient.fetchApplications(configOpt.get(), clusterName);</span>
<span class="nc" id="L955">            apps.addAll(remoteApps);</span>
<span class="nc" id="L956">            Log.infof(</span>
                &quot;Loaded %d applications from remote Startpunkt '%s'&quot;,
<span class="nc" id="L958">                remoteApps.size(), clusterName);</span>
<span class="nc" id="L959">          } catch (Exception e) {</span>
<span class="nc" id="L960">            Log.warnf(</span>
                e,
                &quot;Error loading applications from remote Startpunkt '%s': %s&quot;,
                clusterName,
<span class="nc" id="L964">                e.getMessage());</span>
<span class="nc" id="L965">          }</span>
<span class="nc" id="L966">          continue; // Skip Kubernetes client logic for GraphQL connections</span>
        }

        // Local Kubernetes cluster logic below
<span class="fc" id="L970">        Log.infof(&quot;Attempting to get Kubernetes client for local cluster&quot;);</span>
<span class="fc" id="L971">        KubernetesClient client = multiClusterService.getClient(clusterName);</span>
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">        if (client == null) {</span>
<span class="nc" id="L973">          Log.warnf(&quot;Local cluster is configured but client is null, skipping&quot;);</span>
<span class="nc" id="L974">          continue;</span>
        }

<span class="fc" id="L977">        Log.debugf(&quot;Loading applications from cluster '%s'&quot;, clusterName);</span>

<span class="fc" id="L979">        var applicationWrappers = new ArrayList&lt;BaseKubernetesObject&gt;();</span>
<span class="fc" id="L980">        applicationWrappers.add(new StartpunktApplicationWrapper());</span>

        // For local cluster, check resource availability
        // For remote clusters, we'll need to check availability per cluster
        // For now, we'll use the flags from local cluster
<span class="fc" id="L985">        boolean useHajimari = hajimariEnabled;</span>
<span class="fc" id="L986">        boolean useOpenshift = openshiftEnabled;</span>
<span class="fc" id="L987">        boolean useIngress = ingressEnabled;</span>
<span class="fc" id="L988">        boolean useIstio = istioVirtualServiceEnabled;</span>
<span class="fc" id="L989">        boolean useGatewayApi = gatewayApiEnabled;</span>

        // Only apply resource availability checks for local cluster
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">        if (&quot;local&quot;.equalsIgnoreCase(clusterName)) {</span>
<span class="pc bpc" id="L993" title="2 of 4 branches missed.">          useHajimari = hajimariEnabled &amp;&amp; hajimariResourcesAvailable;</span>
<span class="pc bpc" id="L994" title="1 of 4 branches missed.">          useOpenshift = openshiftEnabled &amp;&amp; openshiftResourcesAvailable;</span>
<span class="pc bpc" id="L995" title="1 of 4 branches missed.">          useIngress = ingressEnabled &amp;&amp; ingressResourcesAvailable;</span>
<span class="pc bpc" id="L996" title="1 of 4 branches missed.">          useIstio = istioVirtualServiceEnabled &amp;&amp; istioResourcesAvailable;</span>
<span class="pc bpc" id="L997" title="1 of 4 branches missed.">          useGatewayApi = gatewayApiEnabled &amp;&amp; gatewayApiResourcesAvailable;</span>
        }

<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">        if (useHajimari) {</span>
<span class="fc" id="L1001">          applicationWrappers.add(new HajimariApplicationWrapper());</span>
        }
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        if (useOpenshift) {</span>
<span class="fc" id="L1004">          applicationWrappers.add(new RouteApplicationWrapper(openshiftOnlyAnnotated));</span>
        }
<span class="fc bfc" id="L1006" title="All 2 branches covered.">        if (useIngress) {</span>
<span class="fc" id="L1007">          applicationWrappers.add(new IngressApplicationWrapper(ingressOnlyAnnotated));</span>
        }
<span class="fc bfc" id="L1009" title="All 2 branches covered.">        if (useIstio) {</span>
<span class="fc" id="L1010">          applicationWrappers.add(</span>
              new IstioVirtualServiceApplicationWrapper(
                  istioVirtualServiceOnlyAnnotated, defaultProtocol));
        }
<span class="fc bfc" id="L1014" title="All 2 branches covered.">        if (useGatewayApi) {</span>
<span class="fc" id="L1015">          applicationWrappers.add(</span>
<span class="fc" id="L1016">              new GatewayApiHttpRouteWrapper(gatewayApiHttpRouteOnlyAnnotated, defaultProtocol));</span>
        }

<span class="fc bfc" id="L1019" title="All 2 branches covered.">        for (BaseKubernetesObject applicationWrapper : applicationWrappers) {</span>
          try {
<span class="fc" id="L1021">            var wrapperApps =</span>
<span class="fc" id="L1022">                applicationWrapper.getApplicationSpecsWithMetadata(</span>
<span class="fc" id="L1023">                    client, anyNamespace, matchNames.orElse(List.of()), clusterName);</span>
<span class="fc" id="L1024">            Log.infof(</span>
                &quot;Wrapper %s loaded %d apps from cluster %s&quot;,
<span class="fc" id="L1026">                applicationWrapper.getClass().getSimpleName(), wrapperApps.size(), clusterName);</span>
<span class="fc" id="L1027">            apps.addAll(wrapperApps);</span>
<span class="nc" id="L1028">          } catch (Exception e) {</span>
<span class="nc" id="L1029">            Log.warnf(</span>
                e,
                &quot;Error loading applications from cluster '%s' using wrapper '%s': %s&quot;,
                clusterName,
<span class="nc" id="L1033">                applicationWrapper.getClass().getSimpleName(),</span>
<span class="nc" id="L1034">                e.getMessage());</span>
<span class="fc" id="L1035">          }</span>
<span class="fc" id="L1036">        }</span>
<span class="fc" id="L1037">        Log.infof(&quot;Total apps after processing cluster %s: %d&quot;, clusterName, apps.size());</span>

<span class="fc" id="L1039">        Log.debugf(&quot;Loaded %d applications from cluster '%s'&quot;, apps.size(), clusterName);</span>
<span class="fc" id="L1040">      }</span>

      // Register URLs for availability checking
<span class="fc bfc" id="L1043" title="All 2 branches covered.">      for (ApplicationResponse app : apps) {</span>
<span class="pc bpc" id="L1044" title="1 of 4 branches missed.">        if (app.getUrl() != null &amp;&amp; !app.getUrl().isEmpty()) {</span>
<span class="fc" id="L1045">          availabilityCheckService.registerUrl(app.getUrl());</span>
        }
<span class="fc" id="L1047">      }</span>

      // Sort and cache
<span class="fc" id="L1050">      Collections.sort(apps);</span>

      // Clear and repopulate cache
<span class="fc" id="L1053">      applicationCacheService.clear();</span>
<span class="fc" id="L1054">      applicationCacheService.putAll(apps);</span>

      // Note: We don't broadcast STATUS_CHANGED here to avoid feedback loops.
      // Individual add/update/delete handlers already broadcast specific events.
      // The AvailabilityCheckService will broadcast STATUS_CHANGED when availability changes.

<span class="fc" id="L1060">      Log.debugf(&quot;Reloaded %d applications into cache from all clusters&quot;, apps.size());</span>
<span class="fc" id="L1061">    } catch (Exception e) {</span>
<span class="fc" id="L1062">      Log.error(&quot;Error reloading application cache&quot;, e);</span>
<span class="fc" id="L1063">    }</span>
<span class="fc" id="L1064">  }</span>

  /** Reloads the entire bookmark cache from Kubernetes and remote Startpunkt instances. */
  private void reloadBookmarkCache() {
    try {
<span class="fc" id="L1069">      Log.debug(&quot;Reloading bookmark cache&quot;);</span>

<span class="fc" id="L1071">      List&lt;BookmarkResponse&gt; bookmarks = new ArrayList&lt;&gt;();</span>

      // Iterate through all active clusters
<span class="fc bfc" id="L1074" title="All 2 branches covered.">      for (String clusterName : multiClusterService.getActiveClusterNames()) {</span>
<span class="fc" id="L1075">        Log.debugf(&quot;Processing bookmarks from cluster: %s&quot;, clusterName);</span>
<span class="fc" id="L1076">        Optional&lt;ClusterConfig&gt; configOpt = multiClusterService.getClusterConfig(clusterName);</span>

        // Check if this is a remote GraphQL cluster (not local)
<span class="pc bpc" id="L1079" title="3 of 4 branches missed.">        if (configOpt.isPresent() &amp;&amp; !&quot;local&quot;.equalsIgnoreCase(clusterName)) {</span>
<span class="nc" id="L1080">          Log.debugf(&quot;Loading bookmarks from remote Startpunkt '%s' via GraphQL&quot;, clusterName);</span>
          try {
<span class="nc" id="L1082">            List&lt;BookmarkResponse&gt; remoteBookmarks =</span>
<span class="nc" id="L1083">                remoteStartpunktClient.fetchBookmarks(configOpt.get(), clusterName);</span>
<span class="nc" id="L1084">            bookmarks.addAll(remoteBookmarks);</span>
<span class="nc" id="L1085">            Log.debugf(</span>
                &quot;Loaded %d bookmarks from remote Startpunkt '%s'&quot;,
<span class="nc" id="L1087">                remoteBookmarks.size(), clusterName);</span>
<span class="nc" id="L1088">          } catch (Exception e) {</span>
<span class="nc" id="L1089">            Log.warnf(</span>
                e,
                &quot;Error loading bookmarks from remote Startpunkt '%s': %s&quot;,
                clusterName,
<span class="nc" id="L1093">                e.getMessage());</span>
<span class="nc" id="L1094">          }</span>
<span class="nc" id="L1095">          continue; // Skip local cluster logic for GraphQL remote clusters</span>
        }

        // Local cluster logic
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">        if (&quot;local&quot;.equalsIgnoreCase(clusterName)) {</span>
<span class="fc" id="L1100">          Log.debugf(&quot;Loading bookmarks from local cluster&quot;);</span>
          // Load Startpunkt bookmarks
<span class="fc" id="L1102">          bookmarks.addAll(bookmarkService.retrieveBookmarks());</span>

          // Load Hajimari bookmarks if enabled and available
<span class="pc bpc" id="L1105" title="2 of 4 branches missed.">          if (hajimariEnabled &amp;&amp; hajimariResourcesAvailable) {</span>
<span class="fc" id="L1106">            bookmarks.addAll(bookmarkService.retrieveHajimariBookmarks());</span>
          }
        }
<span class="fc" id="L1109">      }</span>

      // Clear and repopulate cache
<span class="fc" id="L1112">      bookmarkCacheService.clear();</span>
<span class="fc" id="L1113">      bookmarkCacheService.putAll(bookmarks);</span>

      // Note: We don't broadcast STATUS_CHANGED here to avoid feedback loops.
      // Individual add/update/delete handlers already broadcast specific events.

<span class="fc" id="L1118">      Log.debugf(&quot;Reloaded %d bookmarks into cache from all clusters&quot;, bookmarks.size());</span>
<span class="fc" id="L1119">    } catch (Exception e) {</span>
<span class="fc" id="L1120">      Log.error(&quot;Error reloading bookmark cache&quot;, e);</span>
<span class="fc" id="L1121">    }</span>
<span class="fc" id="L1122">  }</span>

  /** Stops all informers. */
  private void stopInformers() {
<span class="fc bfc" id="L1126" title="All 2 branches covered.">    for (SharedIndexInformer&lt;?&gt; informer : informers) {</span>
      try {
<span class="fc" id="L1128">        informer.stop();</span>
<span class="nc" id="L1129">      } catch (Exception e) {</span>
<span class="nc" id="L1130">        Log.warn(&quot;Error stopping informer&quot;, e);</span>
<span class="fc" id="L1131">      }</span>
<span class="fc" id="L1132">    }</span>
<span class="fc" id="L1133">    informers.clear();</span>
<span class="fc" id="L1134">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>